<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql的索引和存储过程]]></title>
    <url>%2Fposts%2Fd48f24db.html</url>
    <content type="text"><![CDATA[mysql的索引和存储过程 1、索引：针对数据所建立的目录好处，加快了查询速度坏处，降低了增删改的速度，增大了表的文件大小（索引文件可能比数据文件还要大）操作大量数据时最好：先去掉索引，再导入，最后统一加索引 案例：设有新闻表15列，10列上有索引，共500w行数据，如何快速导入？ 把空表的索引全部删除 导入数据 数据导入完毕后，集中建索引 索引使用原则： 不过度索引 索引条件列（where后面最频繁的条件比较适宜索引） 索引散列值，过于集中的值不要索引 索引类型： 普通索引：index 仅仅加快查询速度 唯一索引：unique index 行上的值不能重复 主键索引：primary key 不能重复 全文索引：fulltex index 主键必唯一，但是唯一索引不一定是主键；一张表上，只能有一个主键，但是可以有一个或多个唯一索引 查看一个表上的所有索引：show index from 表名;建立索引：123alter table 表名 add index/unique index/fulltex index 索引名(列名)alter table 表名 add primary key (列名) //不要加索引，因为主键只有一个 删除非主键索引：1alter table 表名 drop index 索引名; 删除主键索引:1alter table 表名 drop index primary key; 全文索引用法：12select * from 表名 where match(列名) against(&apos;要匹配的词或句子&apos;);select id ,email,match(列名) against(&apos;要匹配的词或句子&apos;) from 表名;//显示匹配度 关于全文索引的停止词：全文索引不针对非常频繁的词做索引，如this，is，you，my等 全文索引：在mysql的默认情况下，对于中文意义不大因为英文有空格，标点符号来拆成单词，进而对单词进行索引，而对于中文，没有空格来隔开单词，mysql无法识别每个单词 2、存储过程：类似于函数，就是把一段代码封装取来，当要执行这一段代码的时候，可以通过调用该存储过程来实现。在封装的语句体里面，可以用if/else,case,while等控制结构。可以进行mysql编程。 查看现有的存储过程：1show procedure status \G; #\G 为横向显示 删除存储过程：1drop procedure 存储过程的名字; 创建存储过程： 简单创建 1234create procedure p1() begin select * from g; end&amp; 调用： 1call p1()&amp; 传参 1234create procedure p2(n int) begin select * from g where num &gt;n; end&amp; 1call p2(10)&amp; 控制结构 12345678create procedure p3(n int, j char(1)) begin if j=&apos;h&apos; then select * from g where num &gt;n; else select * from g where num &lt;n; end if; end&amp; 1call p3(10,&apos;h&apos;)&amp; 循环结构 123456789101112create procedure p4(n smallint) begin declare i smallint; declare s int; set i=1; set s=0; while i&lt;=n do set s=s+i; set i=i+1; end while; select s; end&amp; 1call p4(100)&amp; 在mysql中，存储过程和函数的区别： 名称不同 存储过程没有返回值]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql存储引擎、事务与备份和恢复]]></title>
    <url>%2Fposts%2F1edaf0e4.html</url>
    <content type="text"><![CDATA[mysql存储引擎、事务与备份和恢复 1、存储引擎:数据库对同样的数据，有着不同的存储方式和管理方式例如：一部电影在硬盘上有MP4,wmv,rmvb,flv等存储格式，所占空间与清晰度各不一样。表里的数据也是如此，存储方法有多种；对于用户来说，同一张表的数据，无论用什么引擎来存储，用户看到的数据是一样的；对于服务器来说，是由区别的。常用引擎：myisam，innodb，bdb，memory，archive等 myisam，批量插入速度快，不支持事务安全，锁表，全文索引innodb，批量插入相对较慢，支持事务安全，锁行，全文索引 create table t(...)engine myisam chaset utf8; 2、事物：通俗来讲，指一组操作要么成功执行，要么都不执行—–&gt;原子性在所有操作没有执行完成之前，其他会话不能够看到中间的过程——&gt;隔离性事务发生前和发生之后，数据总额依然匹配——-&gt;一致性事务产生的影响不能撤销——&gt;持久性如果出错，事务也不能撤销，只能通过“补偿事务” 开启事务：start transaction;sql语句…sql语句…………….sql语句…commit提交、rollback回滚当一个事务执行commit或rollback时，事务就已经结束了 注意：一些语句会造成事务的饮食提交，比如：start transaction; 事务的基本原理：作用到事务日志文件，commit时才会真正作用到表数据文件 3、备份与恢复：系统运行中，增量备份、整体备份例：每周日整体备份一次，周一到周六备份当天；若周五出现问题，可以用周日的整体备份+周一、二、三、四来恢复备份工具：第三方收费的、系统自带的（mysqldump）mysqldump可以导出：表： mysqldump -u用户名 -p密码 库名 表1 表2 …&gt; 地址/备份文件名称 导出的是建表语句及insert语句 导出一个库下的所有表：mysqldump -u用户名 -p密码 库名 &gt; 地址/备份文件名称 库：以库为单位导出 mysqldump -u用户名 -p密码 -B 库1 库2 &gt; 地址/备份文件名称 eps: mysqldump -uroot -p111111 -B mugua php &gt; D:\\mandphp.sql \\导出muguahe和php eps: mysqldump -uroot -p111111 -A &gt; D:\\mandphp.sql //导出所有库 恢复： source D:\\mandphp.sql; 1：登录到mysql命令行如果以库为单位导出的sql文件：mysql &gt; source 备份文件地址对于表级的备份文件：mysql &gt; use 库名，mysql &gt; source 备份文件地址 2：不登录到mysql命令行针对库级的：mysql -uroot -p111111 &lt; 备份文件地址针对表级的：mysql -uroot -p111111 库名 &lt; 备份文件地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql字符集、校对集和触发器]]></title>
    <url>%2Fposts%2F68c2db95.html</url>
    <content type="text"><![CDATA[mysql字符集、校对集和触发器 1、字符集与校对集：create table 表名( 列声明 )charset utf8; set names gbk; mysql字符集设置非常灵活：数据库默认字符集、表默认字符集、列字符集，如果某一个级别没有指定字符集、则继承上一级 客户(gbk)—–&gt;字符集转换器(gbk–&gt;utf8–&gt;utf8;gbk–&gt;gbk–&gt;utf8)——&gt;服务器(utf8)—–&gt;字符集转换器(…)–查询结果—&gt;客户(utf8） 告诉服务器，我给你发送的数据是什么编码的？character_set_client 告诉转换器，转换成什么编码？ charset_set_connection 查询的结果用什么编码？ chanset_set_results 使用方法，例，客户端：set character_set_client=gbk/utf8如果以上3者都为字符集N，则可以简写为set names N 推论：什么时候会乱码？ client声明与事实不符 results与客户端页面不符的时候 什么时候将会丢失数据？connection和服务器的字符集比client 小时 校对集：指字符集的排序规则，一种字符集可以有多种排序规则eps:以utf8为例，我们默认的utf8_general_ci,也可以按二进制来排序，utf8_bin声明校对集：create table (…)charset utf8 collate utf8_general_ci;注意：声明的校对集必须是字符集合法的校对集 2、触发器：trigger作用：简史某种情况并触发某种操作应用场景：电子商城，当一个订单（表）产生时，订单所购的商品的库存量（表）相应减少（监视某表的变化，当其发生某种变化时，触发另一个表的操作，即：多个sql语句是一个整体，一气呵成）监视地点：表监视事件：增删改触发操作：增删改出发时间：after/before创建： create trigger triggerName after/before insert/update on 表名 for each row //sqlserver可选，mysql这一句固定 begin: sql 语句 #一句或多句 end; 设置语句结束符：delimiter $($为设置的结束符) 1.新增订单，库存单相应减少eps:简单实例 create trigger tg1 after insert on o for each row begin update g set num=num-3 where id=2; end$ 删除触发器：drop trigger 触发器名; 查看触发器：show triggers; eps:改进,如何在触发器中引用行的值（增，用new.列名）对于insert而言，新增的行用new来表示，航中的每一列的值，用new.列名来表示 create trigger tg2 after insert on o for each row begin update g set num=num-new.much where id=new.gid; end$ 2.删除一个订单时，库存单相应增加（删，用old.列名）create trigger tg3 after delete on o for each row begin update g set num=num+old.much where id=old.gid; end$ 3.修改订单的数量时（只有much变，数量），库存单相应改变（改前，用old.列名；改后，用new.列名）create trigger tg4 after update on o for each row begin update g set num=num+old.much-new.much where id=new.gid; end$ 4.修改订单(gid和much都可能变)时，库存单相应改变（改前，用old.列名；改后，用new.列名）create trigger tg5 after update on o for each row begin update g set num=num+old.much where id=old.gid; update g set num=num-new.much where id=new.gid; end$ 5.after和before的区别after是先完成数据的增删改，再触发，触发中的语句晚于增删改，无法影响前面的增删改操作before是先完成触发，再增删改，触发的语句先于坚实的增删改发生，我们有机会判断，修改即将发生的操作 目的：触发事件先于监事事件发生，并判断监视事件的数据 create trigger tg6 before insert on o for each row begin if new.much&gt;5 then set new .much=5; end if; update g set num=num-new.much where id=new.gid; end$]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql关联查询与视图]]></title>
    <url>%2Fposts%2Fb7dd9e3b.html</url>
    <content type="text"><![CDATA[mysql数据库关联查询与视图 1、union：合并查询结果要求：两次查询的列数一致；推荐：查询的每一列，对应的列的类型一致认识： select goods_id,goods_name,shop_price from goods where shop_price&lt;20 or shop_price&gt;5000; select goods_id,goods_name,shop_price from goods where shop_price&gt;5000 union select goods_id,goods_name,shop_price from goods where shop_price&lt;20; 注意： 多次sql语句取出的列名可能不一致，此时，以第1个sql的列名为准 如果不同的语句中取出的行，有完全相同（每个列的值都相同），那么相同的行将会合并。 重复 select id, sum(num) from (select from ta union select from tb) as tmp group by id;//去重复：select id, sum(num) from (select from ta union all select from tb) as tmp group by id;//不去重复,加all： 如果子句中有order by、limit，需加小括号，推荐放到子句之后，即对最终合并的最后结果进行排序； order by和limit组合使用后才有意义，如果order by不配合limit使用，会被语法分析器优化分析时去除，即单独使用order by无效 2、集合相乘，为笛卡尔积，其实就是两集合的完全组合select from ta,tb;即tatb的结果连接查询：左连接、右连接、内连接条件联合查询1：连接表2：连接条件 ； 左连接:leftselect col1 col2,…coln from tableA left join tableB //连接哪几个表 on tableA 列=tableB 列 //连接条件 //此时形成大表，完全当成普通表来看，后可跟where，group，having…一样 右连接:rightselect col1 col2,…coln from tableA right join tableB //连接哪几个表 on tableA 列=tableB 列 //连接条件//此时形成大表，完全当成普通表来看，后可跟where，group，having…一样 内连接：innerselect col1 col2,…coln from tableA inner join tableB //连接哪几个表 on tableA 列=tableB 列 //连接条件//此时形成大表，完全当成普通表来看，后可跟where，group，having…一样 左右连接：A left join B;和B right join A;一样左右连接可以相互转化（推荐使用左连接代替右连接，兼容性好一点） 内连接:查询左右表都有的数据，是左右连接的交集，即：不要左有连接中NULL的那一部分 左右连接的并集，目前不支持mysql不支持外链接，但可以用Union达到目的 3、列增加alter table 表名 add 列声明；增加的列默认在最后一列可以用after来声明新增的列在哪一些后面alter table 表名 add 列声明 after 列名；新增放在第一列：alter table 表名 add 列声明 first; 4、修改列alter table 表名 change 被改变的列名，新的列声明; 5、删除列alter table 表名 drop 列名; 6、视图：view如果某个查询结果出现的非常频繁，也就是拿这个结果当做进行子查询出现的非常频繁。 create table g2 like goods; insert into g2 select .... 上面两句是想保存一个查询结果到表里面，供其它查询用。 视图定义：是由查询结果行程的一张虚拟表。视图创建：create view 视图名 as select语句;视图删除：drop view 试图名;为什么要视图？ 可以简化查询 可以进行一些权限控制，把表的权限封闭，但开放相应的视图权限，视图里只开放部分数据 大数据分表时可以用到 比如，标的行数超过200万行时，就会变慢，可以吧一张表的数据拆成4张表来存放，即分散4张表。 分散方法：最常用的可以用id取模来计算 例：$_GET[‘id’]=17, 17%4+1=2,$tablename=’news’.’2’ select *from news2 where if=17;还可以用视图，把4张表形成一张视图 create view news as select from n1 union selectfrom n2 union …. 视图修改： alter view as select … 7、视图与表的关系：视图是表的查询结果，则表的数据改变了，影响视图的结果，即视图也跟着变；视图的数据改变了？0：视图增删改也会影响表1：但是，视图并不是总是能增删改的2：视图的数据与表的数据一一对应时，可以修改（对于视图insert还应注意：视图必须包含表中没有默认值的列，即：没有默认值的列必须包含进视图） 8、视图的algorithmalgorithm=merge/temptable/undefinedmerge:当引用视图是，引用视图的语句与定义视图的语句合并temptable：当引用视图时，根据视图的创建语句建立一个临时表undefined：未定义，自动，让系统帮你选 merge，意味着视图只是一个规则，语句规则，当查询视图时，把查询视图的语句（比如where那些）与创建时的语句where子句等合并分析，形成一条select语句，执行的是融合的两个语句，查询的原表（原表）；而temptable是根据创建语句瞬间创建一张临时表，然后查询视图的语句从该临时表查数据，最终执行2句话，取数据并放在临时表，然后再去查询临时表（临时表）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql表复制与子查询]]></title>
    <url>%2Fposts%2F86d50104.html</url>
    <content type="text"><![CDATA[mysql表复制与子查询 1、复制表 create table g2 like goods; g2和goods表头都一样，但无内容 insert into g2 select *from goods order by cat_id asc,shop_price desc; 将goods表按cat_id升序、shop_price降序导入到g2表中（无效，还是goods表中原来的顺序） truncate g2; 清空g2表 2、子查询where型、from型、exists型where型：把内层的查询结果作为外层查询的比较条件例：查找每个栏目下最贵的商品 select goods_id, cat_id, goods_name, shop_price from goods where shop_price in (select max(shop_price) from goods group by cat_id); from型：把内层的查询结果当成临时表(必须有别名，即加 as 临时表名)，共外层sql再次查询例：查找每个栏目下最贵的商品 select * from (select goods_id, cat_id, goods_name, shop_price from goods order by cat_id, goods_id desc) as tmp group by cat_id; exist型：把外层的查询结果拿到内层，看内层查询是否成立例：查有商品的栏目（典型） select select cat_id, cat_name, from category where exists (select * from goods where goods.cat_id=category.cat_id); category.cat_id为外层查询结果，它带入内层select；]]></content>
  </entry>
  <entry>
    <title><![CDATA[详解select查询语句]]></title>
    <url>%2Fposts%2F968f054e.html</url>
    <content type="text"><![CDATA[详解select查询语句 where,group by,having,order by,limit按顺序出现：1-5 1、where的常用运算表达式：比较运算符：&lt;,&lt;=,=,in(在某集合内),!=或&lt;&gt;,&gt;,&gt;=,between(在某范围内)逻辑运算符：非：NOT或 |，或：OR或||，与：AND或&amp;&amp; 模糊查询：like-&gt;像%-&gt;通配任意字符‘_’-&gt;通配单个字符 2、group by:把行按字段分组eps：group by col1,col2,…colN 运用场合：常见于统计场合，如按栏目计算帖子数，统计每个人的平均成绩等max,min,sum,avg,count例： select max(shop_price) from goods; select cat_id,max(shop_price) from goods group by cat_id; 可以给列或计算结果取别名，用as select cat_id,sum(shop_price*goods_number) as hk from goods group by cat_id; 3、havingwhere作用于表中的列，having作用于查询结果中的列，其他用法一样所以，两者同时使用时：where在前，having在后查询market_price-shop price大于200的结果 select goods_id,goods_name,market_price-shop price as sheng from where market_price-shop_price&gt;200; select goods_id,goods_name,market_price-shop price as sheng from having sheng&gt;200; 综合一下： select name,sum(score&lt;60) as gk,avg(score) as pj from stu group by name having gk &gt;=2 4、order by 排序功能按一个或多个字段对结果进行排序 select goods_id,goods_name,shop_price from goods where cat_id=3 order by shop_price; 默认升序排列，或用asc声明，若为降序，用desc声明，则 order by shop_price desc； select goods_id,goods_name,shop_price from goods where cat_id&lt;&gt;3 order by cat_id,shop_price desc; 先按cat_id升序排列，再按shop_price降序排列：可按多字段排序 5、limit在语句最后，起到限制条目的作用 Limit[offset]N；offset：偏移量（可选项），N：取出条目 select goods_id, goods_name, shop_price from goods where cat_id&lt;&gt;3 order by cat_id,shop_price desc limit 3,3; 从第三行取，取3行 综合查询，例：取出每个栏目下的最贵的商品 select * from (select goods_id, cat_id, goods_name, shop_price from goods oder by cat_id asc,shop_price desc) as tmp group by cat_id;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql简单入门]]></title>
    <url>%2Fposts%2F96af40f.html</url>
    <content type="text"><![CDATA[1、连接数据库 mysql -h localhost -u root -p Entry password: 2、查看数据库 show databases; 3、创建数据库 create database test; test为数据库名 4、使用选中数据库 use test; 5、显示表 show tables; 6、删除数据库 drop database test; 7、创建表 create table class(stu int,name varchar(20)); class为表名 8、更改表名 rename NewName to OldName; 9、显示表信息 desc class; 注意：命令退出\c 10、建表create table msg( id int, title varchar(60), name varchar(10), content varchar(1000) ); create table class( id int primary key auto_increment, namevarchar(10), age tinyint )charset utf8; 11、增alter table class add age2 tinyint unsigned;增加一列alter table class add age2 tinyint unsigned not null default 0;推荐使用默认值，不为null，默认为0 insert into msg (id,title,name,content) values (1,’初来乍到’,’张三’,’刚来能不能当老大？’); insert into msg (id,title,name,content) values (3,’又来了’,’王五’,’千年老二’),(4,’4标题’,’刘备’,’雌雄双剑’), (5,’5标题’,’关飞’,’大刀’); 12、解决字符集问题默认建表一般用utf8，而我们在问windows下窗口是GBK，因此需要声明字符集 set names gbk; 13、改 update msg set title=’俺来了’, content=’偏要当老大’ where name=’李四’; 14、删 delete from msg where id=2 ; 15、查列 select id,title from msg; 行 select *from msg where id&gt;2; 行列 select id,title from msg where id&gt;2; 详细，查询的5种子句：where,group,having,order by,limit 16、所谓建表：就是声明列的过程列：不同的列类型占的空间不一样选列原则：够用、不浪费 17、详解列类型：整型：tinyint 1/smallint 2/mediumint 3/int 4/bigint 8占据空间、存储范围默认有符号tinyint(M) unsigned zerofill M:宽度 无符号 0填充（如果为zerofill，默认为unsigned）alter table class add age2 tinyint unsigned;增加一列 浮点型 ：float（M,D） M:精度（总位数，不包含点） D:标度（小数位）更精确 定点型：decimal（M,D）6，2两者字节：4个字节或8个字节 字符型char(M)：定长字符,M为宽度，可容纳的字符数；0-255varchar(M)：可变长度字符集；有1-2字节记录长度（0-65535，约2w-6w字符，受字符集影响）区别：char 定长，M个字符，如果存的小于M，空格补齐，实占M个；末尾空格去除，存取速度更快varchar 变长，M个字符，如果存的小于M，假设为N,N&lt;=M,实占N+（1-2）个字符；末尾空格保留text：文本类型，可以存比较大的文本段，搜索速度慢，；不用加默认值（加了也没用）；约2w-6w字符，受字符集影响） 日期/时间型，最好有’’,这里省略了，例如:’1992-08-12’year:范围1901-2155；[000表示错误选择]如果输入2位，00-69表示2000-2069，70-99表示1970-1999年year(4)date:典型格式：1992-08-12范围：1000-01-01–&gt;9999-12-31 time:典型格式 hh:mm:ss，范围-838:59:59-&gt;+838:59:59datetime:上面两个结合注意：在开发中，很少使用日期时间类型来表示一个需要的精确到秒的列原因：虽然日期时间类型能精确到秒，且方便查看，但计算不便，故用时间戳（int）来表示，即1970-01-01 00:00:00到当前的秒数，也方便格式化显示 enum()：枚举类型set():集合型]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2Fposts%2F177574ba.html</url>
    <content type="text"><![CDATA[测试功能简单实例 当开发一个Unix服务器程序时，一般有两种类型可供选择 当开发一个Unix服务器程序时，一般有两种类型可供选择 当开发一个Unix服务器程序时，一般有两种类型可供选择 当开发一个Unix服务器程序时，一般有两种类型可供选择 Download Now]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户/服务器设计范式]]></title>
    <url>%2Fposts%2Fc1208a6.html</url>
    <content type="text"><![CDATA[TCP客户-服务器程序设计范式 当开发一个Unix服务器程序时，一般有两种类型可供选择：迭代服务器、并发服务器。相对来说，客户程序的编写通常比服务器程序容易些，因为客户中进程控制要少得多。针对TCP服务器，总结了9个不同的服务器程序设计范式。 1.迭代服务器迭代TCP服务器总是在完全处理某个客户的请求之后才开始下一个客户。这样的服务程序比较少见。 2.并发服务器，每个客户请求fork一个子进程传统并发服务器调用fork派生一个子进程来处理每个客户，这使得服务器能够同时为多个客户服务，每个进程一个客户。客户数目的唯一限制是操作系统对其能够同时拥有多少子进程的限制。绝大多数TCP服务器程序都是按这个范式编写。并发服务器的问题在于为每个客户现场fork一个子进程比较耗费CPU时间。 3.预先派生子进程服务器，accept无上锁保护使用该技术的服务器不同于传统意义的并发服务器那样为每个客户现场派生一个子进程，而是在启动阶段预先派生一定数量的子进程，当有客户连接到达时，这些子进程就能立即为它提供服务。这种技术的有点在于无需引入父进程执行fork的开销就能处理新到来的客户。缺点是父进程必须在服务启动阶段猜测需要预先派生多少子进程。如果某个时刻客户数恰好等于子进程总数，那么新到的客户将被忽略，直到至少有一个子进程完成处理重新可用。 存在惊群问题 即当一个子进程将获得连接时，所有N个子进程都被唤醒，其中只有最先运行的子进程获得那个客户的连接，其余N-1个子进程继续回复睡眠。 使用select冲突问题 当多个进程在引用同一个套接字的描述符上调用select（例：监听套接字描述符）时就会发生冲突，因为在socket结构中为存放本套接字就绪之时应该唤醒哪些进程而分配的仅仅只是一个进程ID空间。如果有多个进程在等待同一个套接字，那么内核必须唤醒的是阻塞在select调用中的所有进程，因为它不知道那些进程受刚变得就绪的这个套接字的影响。 总结：如果有多个进程阻塞在引用同一个实体（例如套接字或普通文件，由file结构或间接描述）的描述符上，那么最好直接阻塞在诸如accept之类的函数而不是select之中。 4.预先派生子进程,accept使用文件上锁保护在多个进程中引用同一个监听套接字的描述符上调用accept，这种做法在某些系统的内核实现是不被支持的，同时针对前面所述惊群问题，解决办法是让应用进程在调用accept前后安装某种形式的锁(lock),这样任意时刻只有一个子进程阻塞在accept调用中，其他子进程则阻塞在获取保护accept的锁上。使用文件锁来保证每次只有一个子进程阻塞在accept调用中,不过文件锁涉及到文件系统的操作，可能比较耗时。 5.预先派生子进程服务器,accept使用线程上锁保护使用线程锁保护accept，对比文件锁保护accept，这种方法不仅适用于同一进程内各个线程间的锁保护，而且能够用于不同进程之间的锁保护。在不同进程间上锁要求; 互斥锁变量必须存放在由所有进程共享的内存区中； 必须告知线程函数库这是在不通进程之间共享的互斥锁。这同样要求线程库支持PTHREAD_RPOCESS_SHARED属性。 6.预先派生子进程服务器，父进程向子进程传递套接字描述符只让父进程调用accept，然后把所接受的已经连接的套接字传递给某个子进程。这么做绕过了为所有子进程的accept调用提供上锁保护的需求，但是需要从父进程到子进程进行某种形式的描述符传递。这种技术会上代码比较复杂，父进程必须跟踪子进程的闲忙状态，以便于给空闲的子进程传递新的套接字。 这种父进程通过字节流管道把描述符传递到各个子进程，并且各个子进程通过字节流管道写回单个字节，相比共享内存区的互斥锁和使用文件锁，更为费时。 7.并发服务器，每个客户一个线程相比于上述的多进程模型，如果服务器主机提供支持线程，我们可以改用线程以取代进程。线程相比于进程的优势更多，具体不再赘述。 8.预先创建线程服务器，每个线程accept使用锁保护预先派生一个子进程池快于为每个客户现场派生一个子进程；在支持线程的系统上，在福取其启动阶段预先创建的线程池取代为每个客户现场创建一个线程的做法有类似的性能加速。这种服务器的基本设计是预先创建一个线程，并让每个线程各自调用accept，取代让每个线程都阻塞在accept调用中的做法，使用互斥锁保证任何时刻只有一个线程在调用accept。 9.预先创建线程服务器，主线程统一accept这种程序设计范式是在程序启动阶段创建一个线程池后让主线程调用accept并把每个客户连接传递给池中某个可用线程。 这样的设计问题在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。 有很多实现手段，本可用如前面一样使用描述符传递，但是既然所有线程和所有描述符都在同一个进程中，那么也就没有必要把一个描述符从一个线程传递到另一个线程。接收线程只需要知道这个已连接套接字描述符的值，而描述符传递实际传递的并非这个值，而是对这个套接字的引用，因此也将返回一个不同于原值的描述符（该套接字的引用计数也会增加）。 总结： 当系统负载较轻时，每来一个客户请求现场派生一个子进程为之服务的传统并发服务器程序模型就足够了。这个模型甚至可以与inetd结合使用，也就是inetd处理每个连接的接受。 相比传统的每个客户fork一次设计范式，预先创建一个子进程池或一个线程池的范式能够把进程控制CPU时间降低10倍或以上。编写这些范式的程序并不会复杂，不过会有额外的工作，比如监视现在子进程数，随着所服务客户数的动态变化而增加或减少这个数目。 某些实现允许多个子进程或线程阻塞在同一个accept调用中，另外的实现却要求对accept调用需要某种类型的锁加以保（文件锁或者线程互斥锁等）。 让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accept并把描述符传递个子进程或线程来的简单和快速。 由于潜在select冲突的原因，让所有子进程或线程阻塞在同一个accept调用中比让他们阻塞在同一个select调用中更可取。 使用线程通常远快于使用进程，不过选择每个客户一个子进程还是每个客户一个线程取决于操作系统提供什么支持(某些系统不提供线程支持)，还可能取决于为服务每个客户需要激活其他什么程序。举例来说，如果accept客户连接的服务器调用fork和exec（譬如说inetd超级守护进程），那么fork一个单线程的进程可能快于fork一个多线程的进程，另外还有资源等方面的综合考虑。]]></content>
      <categories>
        <category>UNIX</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>客户-服务器</tag>
      </tags>
  </entry>
</search>
